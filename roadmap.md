# 🚀 개발 로드맵

## Phase 0: 기술 스택 확정 및 초기 설정
- [ ] **Step 1**: API 선택 및 계정 설정 (Groq, Google Gemini)
- [ ] **Step 2**: API 키 발급 및 환경 변수 설정 (`.env` 파일)
- [ ] **Step 3**: Vite + React + Tailwind CSS 프로젝트 초기화

## Phase 1: 데이터 구축 및 기본 UI
- [ ] **Step 4**: 1~9세대 한국어 포켓몬 이름 데이터 수집 및 `pokemonData.json` 구축
  - 포켓몬 이름, 세대 정보 포함
  - JSON 형식: `[{ "id": 1, "name": "이상해씨", "generation": 1 }, ...]`
- [ ] **Step 5**: 포켓몬 도감 컨셉의 기본 레이아웃 구조 및 테마 색상(Red) 적용
- [ ] **Step 6**: 음성 입력 UI 컴포넌트 (마이크 버튼, 녹음 상태 표시)
- [ ] **Step 7**: 대화 히스토리 UI (사용자/AI 말풍선, 스크롤)

## Phase 2: 핵심 게임 엔진 (Local Logic)
- [ ] **Step 8**: 단어 검증 로직(`validateWord`) 구현
  - 포켓몬 DB 존재 여부 확인
  - 중복 사용 체크
  - 끝말잇기 규칙 검증
- [ ] **Step 9**: 한국어 두음법칙 처리 로직 구현
  - 'ㄹ' → 'ㅇ' 변환 (예: '리' → '이')
  - 'ㄴ' → 'ㅇ' 변환 (예: '뇨' → '요')
  - 받침 처리 (예: '잠만보' → '보' 또는 '뽀')
- [ ] **Step 10**: 상대 봇의 단어 선택 로직 구현
  - 현재 글자로 시작하는 미사용 포켓몬 검색
  - 랜덤 또는 전략적 선택 알고리즘
- [ ] **Step 11**: 힌트 생성 알고리즘 구현
  - 규칙에 맞는 미사용 단어 하나 추출
  - 힌트 요청 시 사용자에게 제공

## Phase 3: 로컬 게임 로직 테스트
- [ ] **Step 12**: 단어 검증 및 두음법칙 단위 테스트 작성
- [ ] **Step 13**: 엣지 케이스 처리 (마지막 글자가 받침인 경우, 데이터 없는 경우 등)
- [ ] **Step 14**: 게임 종료 조건 구현 (패배/승리 판정)

## Phase 4: AI 인터페이스 통합 (Audio & API)
- [ ] **Step 15**: Web MediaRecorder API를 활용한 음성 녹음 기능 구현
- [ ] **Step 16**: Groq API 연동 및 실시간 STT 구현
  - Whisper 모델 사용
  - 오디오 파일 포맷 변환 (Blob → Base64/File)
- [ ] **Step 17**: Google Gemini API 연동 및 테스트
  - API 호출 및 응답 처리
  - 에러 핸들링 (네트워크 오류, API 한도 초과 등)
- [ ] **Step 18**: 하이브리드 응답 프롬프트 설계
  - 게임 규칙 설명
  - 포켓몬 마스터 페르소나 정의
  - 단어 제시 + 캐릭터 대사 생성
- [ ] **Step 19**: 힌트 요청 전용 대화 프롬프트 최적화
  - 힌트 요청 의도 파악
  - 자연스러운 힌트 제공 방식
- [ ] **Step 20**: Web Speech API를 활용한 즉각적인 TTS 음성 출력 구현
  - 한국어 음성 설정
  - 음성 재생 상태 관리

## Phase 5: UX 고도화 및 폴리싱
- [ ] **Step 21**: 음성 인식 중 상태 표시 (로딩 애니메이션, 파형 효과)
- [ ] **Step 22**: 게임 종료 처리 UI 및 애니메이션 효과 추가
  - 승리/패배 모달
  - 게임 통계 표시 (총 턴 수, 사용한 포켓몬 수)
- [ ] **Step 23**: 반응형 디자인 및 모바일 최적화
- [ ] **Step 24**: 접근성 개선 (키보드 단축키, 스크린 리더 지원)

## Phase 6: 배포 및 성능 최적화
- [ ] **Step 25**: Vercel 배포 설정 및 환경 변수 등록
- [ ] **Step 26**: HTTPS 환경 검증 (마이크 권한 필수)
- [ ] **Step 27**: 번들 사이즈 최적화 (코드 스플리팅, 트리 쉐이킹)
- [ ] **Step 28**: API 응답 시간 측정 및 최적화
- [ ] **Step 29**: 통합 테스트 및 사용자 테스트 (실제 환경)
- [ ] **Step 30**: 최종 버그 수정 및 프로덕션 릴리스

---

## 📝 참고 사항

### 우선순위 높은 단계
- **Phase 0-2**: 프로젝트의 핵심 기반이므로 먼저 완료 필요
- **Step 8-10**: 게임 로직의 핵심, 철저한 검증 필요
- **Step 16-18**: AI 통합의 핵심, API 비용과 응답 시간 고려

### 반복 작업이 예상되는 단계
- **Step 9**: 한국어 두음법칙 예외 케이스가 많아 지속적 개선 필요
- **Step 18-19**: LLM 프롬프트는 반복적인 튜닝과 테스트 필요
- **Step 27-28**: 성능 최적화는 지속적인 모니터링과 개선 필요

### 기술적 난이도 높은 단계
- **Step 9**: 한국어 언어학적 예외 처리
- **Step 16**: 오디오 스트리밍 및 포맷 변환
- **Step 18**: 효과적인 프롬프트 엔지니어링
