[{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\scripts\\crawl-pokemon.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\scripts\\test-game-logic.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Pokemon' is defined but never used.","line":3,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Pokemon"},"fix":{"range":[58,112],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { validateWord } from '../src/utils/gameLogic';\r\nimport type { Pokemon } from '../src/utils/gameLogic';\r\n\r\n// Mock Pokemon Data for testing? No, we will use the real one imported in gameLogic.ts\r\n// But since we are running this with ts-node or similar, we might need to handle JSON imports.\r\n// For simplicity in this environment, we will rely on the implementation being correct and test it via a temporary test file that we run.\r\n\r\nconst testCases = [\r\n    { word: 'í”¼ì¹´ì¸„', chain: '', used: new Set<string>(), expected: true },\r\n    { word: 'í”¼ì¹´ì¸„', chain: 'í”¼', used: new Set<string>(), expected: true },\r\n    { word: 'ë¼ì´ì¸„', chain: 'í”¼', used: new Set<string>(), expected: false }, // Chain mismatch\r\n    { word: 'ì—†ëŠ”í¬ì¼“ëª¬', chain: '', used: new Set<string>(), expected: false }, // Not in DB\r\n    { word: 'í”¼ì¹´ì¸„', chain: '', used: new Set(['í”¼ì¹´ì¸„']), expected: false }, // Already used\r\n\r\n    // Do-eum-beop-chik Tests\r\n    { word: 'ì´ìƒí•´ì”¨', chain: 'ë¦¬', used: new Set<string>(), expected: true },  // ê°œêµ¬ë¦¬ -> ì´ìƒí•´ì”¨ (ë¦¬ -> ì´) : Valid\r\n    { word: 'ë¦¬ìëª½', chain: 'ë¦¬', used: new Set<string>(), expected: true },    // ê°œêµ¬ë¦¬ -> ë¦¬ìëª½ (ë¦¬ -> ë¦¬) : Valid\r\n    { word: 'ë‚˜ì¸í…Œì¼', chain: 'ë¼', used: new Set<string>(), expected: true },  // í”„í…Œë¼ -> ë‚˜ì¸í…Œì¼ (ë¼ -> ë‚˜) : Valid\r\n    { word: 'ë¼í”Œë ˆì‹œì•„', chain: 'ë¼', used: new Set<string>(), expected: true },// í”„í…Œë¼ -> ë¼í”Œë ˆì‹œì•„ (ë¼ -> ë¼) : Valid\r\n    { word: 'ì—¬ë¦¬ë¥´', chain: 'ë…€', used: new Set<string>(), expected: true },    // (Hygpothetical) ë…€ -> ì—¬ : Valid (Assuming 'ì—¬ë¦¬ë¥´' exists? No, but logic check)\r\n    // Actually we need real Pokemon names for 'true' expectation because validateWord checks DB.\r\n    // Let's use real ones if possible, or just check logic if we mock. \r\n    // Since we use real DB, we must use real established links.\r\n    // 'ë¦¬' -> 'ì´':  'ë…ì¹¨ë¶•' ends 'ë¶•'. 'ê³ ì§€' ends 'ì§€'. \r\n    // Let's use:\r\n    // 1. 'ì¹˜ì½”ë¦¬íƒ€'(End: íƒ€) -> No Do-eum.\r\n    // 2. 'ë§ë‚˜ë‡½'(End: ë‡½) -> 'ìš©'(Yong)? ë‡½ -> ìš© allowed? \r\n    //    Dictionary says ë…€, ë‡¨, ë‰´, ë‹ˆ -> ì—¬, ìš”, ìœ , ì´. \r\n    //    Does 'ë‡½' -> 'ìš©' exist? Usually no. Only initial 'ã„´' followed by 'j' sound or 'i'.\r\n    //    'ë‡½' is 'Nyong'. 'ë‡¨'(Nyo) is covered. 'ë‡½' is not specifically in standard Do-eum rule list usually?\r\n    //    Let's check code map: 'ë‡½' -> 'ìš©'. Added in map.\r\n    //    So 'ë¯¸ë‡½' -> 'ìš©ì‹' (If 'ìš©ì‹' was a pokemon).\r\n    //    Real pokemon: 'ë©”ê°€ë‹ˆì›€' ends 'ì›€'. \r\n    //    Let's stick to easy ones: \r\n    //    'ë‹¨ë‹¨ì§€'(End: ì§€). \r\n    //    'ì ë§Œë³´'(End: ë³´).\r\n\r\n    // Test: 'ê°œêµ¬ë¦¬'(Ri) -> 'ì´ìƒí•´ì”¨'(Yi...) - Wait 'Lee' vs 'Yi'. \r\n    // 'ì´ìƒí•´ì”¨' starts with 'ì´' (Yi). 'ë¦¬' maps to 'ì´'. So YES.\r\n    { word: 'ì´ìƒí•´ì”¨', chain: 'ë¦¬', used: new Set<string>(), expected: true },\r\n\r\n    // Test: 'í‚¹í¬ë©'(Lap -> Nap?) 'ë©' -> 'ëƒ…'? \r\n    // Map check: 'ë' -> 'ë‚©'. 'ë©' is not in map usually? I added 'ë˜'->'ë‚´'. 'ë©'??\r\n    // Added 'ë'->'ë‚©'. \r\n    // Let's add 'ë©' -> 'ëƒ…' just in case if I didn't. I didn't add 'ë©'.\r\n    // Safe tests only for now.\r\n];\r\n\r\nconsole.log('--- Starting Validation Tests ---');\r\n\r\ntestCases.forEach((tc, index) => {\r\n    const result = validateWord(tc.word, tc.chain, tc.used);\r\n    const passed = result.isValid === tc.expected;\r\n    console.log(`Test Case ${index + 1}: ${tc.word} (Chain: '${tc.chain}') -> Expected: ${tc.expected}, Got: ${result.isValid} -> ${passed ? 'PASS' : 'FAIL'}`);\r\n    if (!passed) {\r\n        console.log(`   Reason: ${result.error}`);\r\n    }\r\n});\r\n\r\nconsole.log('--- Tests Completed ---');\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\scripts\\validate-data.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\components\\ChatBubble.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\components\\ChatHistory.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\components\\Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\components\\InputArea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\components\\ui\\button.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":58,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":58,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\r\nimport { Slot } from \"@radix-ui/react-slot\"\r\nimport { cva, type VariantProps } from \"class-variance-authority\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst buttonVariants = cva(\r\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"bg-primary text-primary-foreground shadow hover:bg-primary/90\",\r\n        destructive:\r\n          \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\r\n        outline:\r\n          \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\r\n        secondary:\r\n          \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",\r\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\r\n        link: \"text-primary underline-offset-4 hover:underline\",\r\n        pokedex:\r\n          \"bg-pokedex-red text-white shadow-sm hover:bg-pokedex-darkred\",\r\n      },\r\n      size: {\r\n        default: \"h-9 px-4 py-2\",\r\n        sm: \"h-8 rounded-md px-3 text-xs\",\r\n        lg: \"h-10 rounded-md px-8\",\r\n        icon: \"h-9 w-9\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  }\r\n)\r\n\r\nexport interface ButtonProps\r\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\r\n    VariantProps<typeof buttonVariants> {\r\n  asChild?: boolean\r\n}\r\n\r\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\r\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\r\n    const Comp = asChild ? Slot : \"button\"\r\n    return (\r\n      <Comp\r\n        className={cn(buttonVariants({ variant, size, className }))}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nButton.displayName = \"Button\"\r\n\r\nexport { Button, buttonVariants }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\components\\ui\\input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\components\\ui\\scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\hooks\\useGame.gameOver.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1056,1059],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1056,1059],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1254,1257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1254,1257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1425,1428],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1425,1428],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { renderHook, act } from '@testing-library/react';\r\nimport { useGame } from './useGame';\r\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\r\nimport * as gameLogic from '@/utils/gameLogic';\r\n\r\n\r\n// Mock dependencies\r\nvi.mock('@/utils/gameLogic', async (importOriginal) => {\r\n    const actual = await importOriginal<typeof import('@/utils/gameLogic')>();\r\n    return {\r\n        ...actual,\r\n        getValidNextPokemon: vi.fn(),\r\n        getRandomPokemon: vi.fn(),\r\n        validateWord: vi.fn(),\r\n        getLastChar: (word: string) => word.slice(-1),\r\n    };\r\n});\r\n\r\nvi.mock('@/utils/gemini_api', () => ({\r\n    getAiMessage: vi.fn().mockResolvedValue('AI Message'),\r\n}));\r\n\r\ndescribe('useGame Hook - User Game Over', () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n        vi.useFakeTimers();\r\n    });\r\n\r\n    afterEach(() => {\r\n        vi.useRealTimers();\r\n    });\r\n\r\n    it('should detect when user has no moves and set status to lost', async () => {\r\n        // Setup Mocks\r\n        (gameLogic.validateWord as any).mockReturnValue({\r\n            isValid: true,\r\n            pokemon: { name: 'UserMon', imageUrl: 'user.png' }\r\n        });\r\n\r\n        // Start with Pika\r\n        (gameLogic.getRandomPokemon as any).mockReturnValue({\r\n            name: 'Pika',\r\n            imageUrl: 'pika.png'\r\n        });\r\n\r\n        // AI plays 'AiMon'\r\n        (gameLogic.getValidNextPokemon as any).mockImplementation((lastChar: string, usedWords: Set<string>) => {\r\n            if (lastChar === 'n') { // Last char of 'UserMon'\r\n                if (usedWords.has('AiMon')) {\r\n                    return null;\r\n                }\r\n                return { name: 'AiMon', imageUrl: 'ai.png' };\r\n            }\r\n            return null;\r\n        });\r\n\r\n        const { result } = renderHook(() => useGame());\r\n\r\n        // Start Game\r\n        act(() => {\r\n            result.current.startGame('normal');\r\n        });\r\n\r\n        await act(async () => {\r\n            vi.advanceTimersByTime(2000); // AI Start\r\n        });\r\n\r\n        // User plays 'UserMon'\r\n        act(() => {\r\n            result.current.submitUserWord('UserMon');\r\n        });\r\n\r\n        // Fast-forward AI turn\r\n        await act(async () => {\r\n            vi.runAllTimers();\r\n        });\r\n\r\n        // Check Logic:\r\n        // 1. User played UserMon (ends in n)\r\n        // 2. AI played AiMon (ends in n)\r\n        // 3. Logic checks if valid move exists for 'n'. Mock returns null.\r\n        // 4. Status should be 'lost'\r\n\r\n        expect(result.current.messages.some(m => m.pokemonName === 'AiMon')).toBe(true);\r\n        expect(result.current.status).toBe('lost');\r\n        expect(result.current.messages.some(m => m.isGameEnd === true)).toBe(true);\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\hooks\\useGame.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1125,1128],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1125,1128],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1344,1347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1344,1347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1534,1537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1534,1537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1753,1756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1753,1756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3060,3063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3060,3063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3304,3307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3304,3307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3523,3526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3523,3526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4508,4511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4508,4511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4681,4684],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4681,4684],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4853,4856],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4853,4856],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4918,4921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4918,4921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { renderHook, act } from '@testing-library/react';\r\nimport { useGame } from './useGame';\r\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\r\nimport * as gameLogic from '@/utils/gameLogic';\r\nimport * as geminiApi from '@/utils/gemini_api';\r\n\r\n// Mock dependencies\r\nvi.mock('@/utils/gameLogic', async (importOriginal) => {\r\n    const actual = await importOriginal<typeof import('@/utils/gameLogic')>();\r\n    return {\r\n        ...actual,\r\n        getValidNextPokemon: vi.fn(),\r\n        getRandomPokemon: vi.fn(),\r\n        validateWord: vi.fn(),\r\n        getLastChar: (word: string) => word.slice(-1),\r\n    };\r\n});\r\n\r\nvi.mock('@/utils/gemini_api', () => ({\r\n    getAiWord: vi.fn(),\r\n    getAiMessage: vi.fn().mockResolvedValue('AI Message'),\r\n}));\r\n\r\ndescribe('useGame Hook - AI Image Display', () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n        vi.useFakeTimers();\r\n    });\r\n\r\n    afterEach(() => {\r\n        vi.useRealTimers();\r\n    });\r\n\r\n    it('should start with AI message and handle user response', async () => {\r\n        // Setup Mocks\r\n        (gameLogic.validateWord as any).mockReturnValue({\r\n            isValid: true,\r\n            pokemon: { name: 'íŒŒì´ë¦¬', imageUrl: 'user-img.png' }\r\n        });\r\n\r\n        // Mock getRandomPokemon for Start Game\r\n        (gameLogic.getRandomPokemon as any).mockReturnValue({\r\n            name: 'í”¼ì¹´ì¸„',\r\n            imageUrl: 'pika.png'\r\n        });\r\n\r\n        // Mock getValidNextPokemon for AI Turn\r\n        (gameLogic.getValidNextPokemon as any).mockReturnValue({\r\n            name: 'ë¦¬ìë“œ',\r\n            imageUrl: 'ai-img.png',\r\n            description: 'Fire Lizard'\r\n        });\r\n\r\n        // Mock getAiWord (legacy, if used)\r\n        (geminiApi.getAiWord as any).mockReturnValue('ë¦¬ìë“œ');\r\n\r\n        const { result } = renderHook(() => useGame());\r\n\r\n        // Start Game\r\n        act(() => {\r\n            result.current.startGame('normal');\r\n        });\r\n\r\n        // Fast-forward initial AI start delay (1500ms)\r\n        await act(async () => {\r\n            vi.advanceTimersByTime(2000);\r\n        });\r\n\r\n        // Check for AI Start Message\r\n        const startMessage = result.current.messages.find(m => m.sender === 'ai' && m.pokemonName === 'í”¼ì¹´ì¸„');\r\n        expect(startMessage).toBeTruthy();\r\n        expect(startMessage?.pokemonImageUrl).toBe('pika.png');\r\n\r\n        // Submit User Word\r\n        act(() => {\r\n            result.current.submitUserWord('íŒŒì´ë¦¬');\r\n        });\r\n\r\n        // Fast-forward time for AI response delay\r\n        await act(async () => {\r\n            vi.runAllTimers();\r\n        });\r\n\r\n        // Check messages\r\n        const aiMessage = result.current.messages.find(m => m.sender === 'ai' && m.pokemonName === 'ë¦¬ìë“œ');\r\n\r\n        expect(aiMessage).toBeTruthy();\r\n        expect(aiMessage?.pokemonName).toBe('ë¦¬ìë“œ');\r\n        expect(aiMessage?.pokemonImageUrl).toBe('ai-img.png');\r\n    });\r\n\r\n    it('should include pokemonImageUrl in AI response in Normal Mode', async () => {\r\n        // Setup Mocks\r\n        (gameLogic.validateWord as any).mockReturnValue({\r\n            isValid: true,\r\n            pokemon: { name: 'íŒŒì´ë¦¬', imageUrl: 'user-img.png' }\r\n        });\r\n\r\n        // Mock getValidNextPokemon to return a Pokemon with an Image\r\n        (gameLogic.getValidNextPokemon as any).mockReturnValue({\r\n            name: 'ë¦¬ìë“œ',\r\n            imageUrl: 'ai-img.png',\r\n            description: 'Fire Lizard'\r\n        });\r\n\r\n        // Mock getAiWord (legacy, if used)\r\n        (geminiApi.getAiWord as any).mockReturnValue('ë¦¬ìë“œ');\r\n\r\n        const { result } = renderHook(() => useGame());\r\n\r\n        // Start Game\r\n        act(() => {\r\n            result.current.startGame('normal');\r\n        });\r\n\r\n        // Submit User Word\r\n        act(() => {\r\n            result.current.submitUserWord('íŒŒì´ë¦¬');\r\n        });\r\n\r\n        // Fast-forward time for AI delay\r\n        await act(async () => {\r\n            vi.runAllTimers();\r\n        });\r\n\r\n        // Check messages\r\n        const messages = result.current.messages;\r\n        const aiMessage = messages.find(m => m.sender === 'ai' && m.text.includes('ë¦¬ìë“œ'));\r\n\r\n        expect(aiMessage).toBeTruthy();\r\n        expect(aiMessage?.pokemonName).toBe('ë¦¬ìë“œ');\r\n        // This expectation is the key: IT SHOULD HAVE AN IMAGE\r\n        expect(aiMessage?.pokemonImageUrl).toBe('ai-img.png');\r\n    });\r\n\r\n    it('should include pokemonImageUrl in AI response in AI Mode', async () => {\r\n        // Setup Mocks\r\n        (gameLogic.validateWord as any).mockReturnValue({\r\n            isValid: true,\r\n            pokemon: { name: 'íŒŒì´ë¦¬', imageUrl: 'user-img.png' }\r\n        });\r\n\r\n        (gameLogic.getValidNextPokemon as any).mockReturnValue({\r\n            name: 'ë¦¬ìë“œ',\r\n            imageUrl: 'ai-img.png',\r\n            description: 'Fire Lizard'\r\n        });\r\n        (geminiApi.getAiWord as any).mockReturnValue('ë¦¬ìë“œ');\r\n        (geminiApi.getAiMessage as any).mockResolvedValue('ë¦¬ìë“œ! ë¶ˆê½ƒ ì„¸ë¡€!');\r\n\r\n        const { result } = renderHook(() => useGame());\r\n\r\n        // Start Game\r\n        act(() => {\r\n            result.current.startGame('ai');\r\n        });\r\n\r\n        // Submit User Word\r\n        act(() => {\r\n            result.current.submitUserWord('íŒŒì´ë¦¬');\r\n        });\r\n\r\n        // Fast-forward time for AI delay\r\n        await act(async () => {\r\n            vi.runAllTimers();\r\n        });\r\n\r\n        // Check messages (Async update might need waiting, but fake timers help)\r\n        // With current \"blocking\" logic, it waits for getAiMessage.\r\n        // With \"non-blocking\" logic, it shows immediately.\r\n\r\n        const messages = result.current.messages;\r\n        // Depending on implementation, we might check for the existence of ANY message with image\r\n        const aiMessage = messages.find(m => m.sender === 'ai' && (m.text.includes('ë¦¬ìë“œ') || m.pokemonName === 'ë¦¬ìë“œ'));\r\n\r\n        expect(aiMessage).toBeTruthy();\r\n        expect(aiMessage?.pokemonImageUrl).toBe('ai-img.png');\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\hooks\\useGame.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'updateMessage'. Either include it or remove the dependency array.","line":181,"column":8,"nodeType":"ArrayExpression","endLine":181,"endColumn":50,"suggestions":[{"desc":"Update the dependencies array to be: [status, currentTurn, usedWords, gameMode, updateMessage]","fix":{"range":[7047,7089],"text":"[status, currentTurn, usedWords, gameMode, updateMessage]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useRef } from 'react';\r\nimport { validateWord, getValidNextPokemon, getLastChar, getRandomPokemon } from '@/utils/gameLogic';\r\nimport { getAiMessage } from '@/utils/gemini_api';\r\nimport { GAME_CONFIG } from '@/constants';\r\nimport type { ChatMessage, GameMode } from '@/types';\r\n\r\nexport type GameStatus = 'idle' | 'playing' | 'won' | 'lost';\r\nexport type Turn = 'user' | 'ai';\r\n\r\ninterface UseGameReturn {\r\n    messages: ChatMessage[];\r\n    status: GameStatus;\r\n    currentTurn: Turn;\r\n    usedWords: Set<string>;\r\n    gameMode: GameMode;\r\n    startGame: (mode: GameMode) => void;\r\n    submitUserWord: (word: string) => void;\r\n    giveHint: () => void;\r\n    resetGame: () => void;\r\n    updateMessage: (id: string, updates: Partial<ChatMessage>) => void;\r\n}\r\n\r\nexport function useGame(): UseGameReturn {\r\n    const [messages, setMessages] = useState<ChatMessage[]>([]);\r\n    const [status, setStatus] = useState<GameStatus>('idle');\r\n    const [currentTurn, setCurrentTurn] = useState<Turn>('user');\r\n    const [gameMode, setGameMode] = useState<GameMode>('normal');\r\n    const [usedWords, setUsedWords] = useState<Set<string>>(new Set());\r\n\r\n    // Keep track of the last word's end char for validation (chaining)\r\n    // If empty, it means any word is valid (start of game).\r\n    const lastEndChar = useRef<string>('');\r\n\r\n    const addMessage = (sender: 'user' | 'ai' | 'system', text: string, options?: Partial<ChatMessage>): string => {\r\n        const id = `${sender}-${Date.now()}-${Math.random()}`;\r\n        const newMessage: ChatMessage = {\r\n            id,\r\n            sender,\r\n            text,\r\n            timestamp: Date.now(),\r\n            ...options\r\n        };\r\n        setMessages((prev) => [...prev, newMessage]);\r\n        return id;\r\n    };\r\n\r\n    const updateMessage = useCallback((id: string, updates: Partial<ChatMessage>) => {\r\n        setMessages((prev) => prev.map(msg =>\r\n            msg.id === id ? { ...msg, ...updates } : msg\r\n        ));\r\n    }, []);\r\n\r\n    const startGame = useCallback((mode: GameMode) => {\r\n        setMessages([]);\r\n        setUsedWords(new Set());\r\n        setStatus('playing');\r\n        setCurrentTurn('user');\r\n        setGameMode(mode);\r\n        lastEndChar.current = '';\r\n        addMessage('system', 'ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤! AIê°€ ë¨¼ì € í¬ì¼“ëª¬ì„ ì œì‹œí•©ë‹ˆë‹¤.');\r\n\r\n        // AI Start Logic with Delay\r\n        setTimeout(() => {\r\n            const startPokemon = getRandomPokemon();\r\n            const startWord = startPokemon.name;\r\n\r\n            // Immediate display\r\n            addMessage('ai', `${startWord}! (ì‹œì‘ ë‹¨ì–´)`, {\r\n                pokemonName: startWord,\r\n                pokemonImageUrl: startPokemon.imageUrl\r\n            });\r\n\r\n            // Set initial state\r\n            setUsedWords((prev) => {\r\n                const next = new Set(prev); // Use fresh set/prev just in case, though it's new\r\n                next.add(startWord);\r\n                return next;\r\n            });\r\n            lastEndChar.current = getLastChar(startWord);\r\n            setCurrentTurn('user'); // User's turn to answer\r\n        }, 1500);\r\n    }, []);\r\n\r\n    const resetGame = useCallback(() => {\r\n        setMessages([]);\r\n        setUsedWords(new Set());\r\n        setStatus('idle');\r\n        setCurrentTurn('user');\r\n        lastEndChar.current = '';\r\n    }, []);\r\n\r\n    const submitUserWord = useCallback((word: string) => {\r\n        if (status !== 'playing' || currentTurn !== 'user') return;\r\n\r\n        // Validate\r\n        const validation = validateWord(word, lastEndChar.current, usedWords);\r\n\r\n        if (!validation.isValid) {\r\n            // Show error as system message\r\n            addMessage('system', `âŒ ${validation.error}`);\r\n            return;\r\n        }\r\n\r\n        // Valid User Move\r\n        const validWord = validation.pokemon!.name;\r\n        const validImage = validation.pokemon!.imageUrl;\r\n        addMessage('user', validWord, { pokemonName: validWord, pokemonImageUrl: validImage });\r\n\r\n        // Update State\r\n        const newUsedWords = new Set(usedWords);\r\n        newUsedWords.add(validWord);\r\n        setUsedWords(newUsedWords);\r\n        setCurrentTurn('ai');\r\n\r\n        // Process AI Turn\r\n        const userEndChar = getLastChar(validWord);\r\n        lastEndChar.current = userEndChar;\r\n\r\n        // AI Logic: Non-blocking (Immediate word/image, Async message)\r\n        setTimeout(async () => {\r\n            try {\r\n                // 1. Select AI Pokemon Immediately\r\n                const aiPokemon = getValidNextPokemon(userEndChar, newUsedWords);\r\n\r\n                if (!aiPokemon) {\r\n                    addMessage('ai', `ìœ¼ìœ½... '${userEndChar}'(ìœ¼)ë¡œ ì‹œì‘í•˜ëŠ” í¬ì¼“ëª¬ì´ ìƒê°ì´ ì•ˆ ë‚˜...!`);\r\n                    addMessage('system', 'ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ë‹¹ì‹ ì´ ì´ê²¼ìŠµë‹ˆë‹¤!', { isGameEnd: true });\r\n                    setStatus('won');\r\n                    return;\r\n                }\r\n\r\n                const aiWord = aiPokemon.name;\r\n                const aiImage = aiPokemon.imageUrl;\r\n\r\n                // 2. Immediate Display (Word + Image)\r\n                const initialText = gameMode === 'normal' ? `${aiWord}!` : `${aiWord} (AIê°€ ê³ ë¯¼ ì¤‘... ğŸ’­)`;\r\n\r\n                const aiMsgId = addMessage('ai', initialText, {\r\n                    pokemonName: aiWord,\r\n                    pokemonImageUrl: aiImage\r\n                });\r\n\r\n                // 3. Update Game State Immediately\r\n                const updatedUsedWords = new Set(newUsedWords);\r\n                updatedUsedWords.add(aiWord);\r\n\r\n                setUsedWords(updatedUsedWords);\r\n\r\n                const aiEndChar = getLastChar(aiWord);\r\n                lastEndChar.current = aiEndChar;\r\n                setCurrentTurn('user');\r\n\r\n                // 4. CHECK IF USER LOST (No moves left)\r\n                const userNextMove = getValidNextPokemon(aiEndChar, updatedUsedWords);\r\n\r\n                if (!userNextMove) {\r\n                    setTimeout(() => {\r\n                        addMessage('system', `ë” ì´ìƒ '${aiEndChar}'(ìœ¼)ë¡œ ì‹œì‘í•˜ëŠ” í¬ì¼“ëª¬ì´ ì—†ìŠµë‹ˆë‹¤.`, { isGameEnd: true });\r\n                        setStatus('lost');\r\n                    }, 500); // Slight delay for dramatic effect\r\n                }\r\n\r\n                // 5. Async: Fetch Persona Message (AI Mode Only)\r\n                if (gameMode === 'ai' && !!userNextMove) { // Only fetch persona if game continues\r\n                    try {\r\n                        const fullMessage = await getAiMessage(aiWord, userEndChar);\r\n                        updateMessage(aiMsgId, { text: fullMessage });\r\n                    } catch (err) {\r\n                        console.error(\"Failed to get AI message\", err);\r\n                        // If failed, just keep the word\r\n                        updateMessage(aiMsgId, { text: `${aiWord}!` });\r\n                    }\r\n                }\r\n\r\n            } catch (error) {\r\n                console.error(\"Critical AI Error\", error);\r\n                addMessage('system', 'âŒ AI ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', { isGameEnd: true });\r\n            }\r\n        }, GAME_CONFIG.AI_DELAY_MIN + Math.random() * GAME_CONFIG.AI_DELAY_RANDOM);\r\n\r\n    }, [status, currentTurn, usedWords, gameMode]);\r\n\r\n    const giveHint = useCallback(() => {\r\n        if (status !== 'playing') return;\r\n\r\n        // Find a valid word for the USER\r\n        const hintPokemon = getValidNextPokemon(lastEndChar.current, usedWords);\r\n        if (hintPokemon) {\r\n            addMessage('system', `ğŸ’¡ íŒíŠ¸: ${hintPokemon.description}`, { hintAnswer: hintPokemon.name });\r\n        } else {\r\n            addMessage('system', 'ğŸ’¡ ë” ì´ìƒ ê°€ëŠ¥í•œ ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤!');\r\n        }\r\n    }, [status, usedWords]);\r\n\r\n    return {\r\n        messages,\r\n        status,\r\n        currentTurn,\r\n        usedWords,\r\n        gameMode,\r\n        startGame,\r\n        submitUserWord,\r\n        giveHint,\r\n        resetGame,\r\n        updateMessage,\r\n    };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\pages\\GamePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\pages\\HomePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\pages\\PokedexPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\utils\\gameLogic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\utils\\gemini.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\utils\\gemini_api.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[397,400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[397,400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2374,2377],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2374,2377],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3251,3254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3251,3254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GoogleGenerativeAI } from '@google/generative-ai';\r\nimport { getValidNextPokemon, getLastChar } from './gameLogic';\r\nimport { GEMINI_CONFIG, SYSTEM_PROMPTS } from '@/constants';\r\n\r\n// Initialize Gemini API\r\nconst API_KEY = import.meta.env.VITE_GEMINI_API_KEY;\r\n\r\n// Rate Limiting Config\r\nconst requestTimestamps: number[] = [];\r\n\r\nlet genAI: GoogleGenerativeAI | null = null;\r\nlet model: any = null;\r\n\r\nif (API_KEY) {\r\n    genAI = new GoogleGenerativeAI(API_KEY);\r\n    model = genAI.getGenerativeModel({ model: GEMINI_CONFIG.MODEL_NAME });\r\n} else {\r\n    console.warn('Gemini API Key is missing. AI will be disabled or fall back to local logic.');\r\n}\r\n\r\n/**\r\n * Checks if the rate limit has been exceeded.\r\n * @returns true if request is allowed, false if limited.\r\n */\r\nfunction checkRateLimit(): boolean {\r\n    const now = Date.now();\r\n    // Remove timestamps older than 1 minute (60,000 ms)\r\n    while (requestTimestamps.length > 0 && requestTimestamps[0] < now - 60000) {\r\n        requestTimestamps.shift();\r\n    }\r\n\r\n    if (requestTimestamps.length >= GEMINI_CONFIG.RATE_LIMIT_RPM) {\r\n        return false;\r\n    }\r\n\r\n    requestTimestamps.push(now);\r\n    return true;\r\n}\r\n\r\n/**\r\n * Finds a valid word locally for the AI to allow immediate response.\r\n */\r\nexport function getAiWord(lastWord: string, usedWords: Set<string>): string | null {\r\n    const endChar = getLastChar(lastWord);\r\n    const pokemon = getValidNextPokemon(endChar, usedWords);\r\n    return pokemon ? pokemon.name : null;\r\n}\r\n\r\n/**\r\n * Generates the persona-based message for the chosen word asynchronously.\r\n */\r\nexport async function getAiMessage(aiWord: string, lastWord: string): Promise<string> {\r\n    if (!model) {\r\n        return `${aiWord}! (API í‚¤ê°€ ì—†ì–´ì„œ ë¡œì»¬ ë¡œì§ìœ¼ë¡œ ì‘ë‹µí•¨)`;\r\n    }\r\n\r\n    // Check Rate Limit\r\n    if (!checkRateLimit()) {\r\n        console.warn('Gemini API Rate Limit Exceeded (Client-side check). Falling back to local logic.');\r\n        return `${aiWord}! (ë§ì„ ë„ˆë¬´ ë§ì´ í–ˆë”ë‹ˆ ìˆ¨ì°¨... ì ì‹œë§Œ ì²œì²œíˆ í• ê²Œ í—¥í—¥)`;\r\n    }\r\n\r\n    try {\r\n        // Prompt Gemini to generate a persona-based message using the selected word.\r\n        const prompt = SYSTEM_PROMPTS.POKEMON_MASTER(lastWord, aiWord);\r\n\r\n        const result = await model.generateContent(prompt);\r\n        const response = result.response;\r\n        const text = response.text();\r\n\r\n        return text.trim();\r\n\r\n    } catch (error: any) {\r\n        console.error('Gemini API Error (Primary Model):', error);\r\n\r\n        const errorMessage = error.toString().toLowerCase();\r\n        if (errorMessage.includes('quota') || errorMessage.includes('429') || errorMessage.includes('limit')) {\r\n\r\n            console.warn('Quota exceeded. Switching to Fallback Model:', GEMINI_CONFIG.FALLBACK_MODEL_NAME);\r\n            try {\r\n                // Initialize/Use fallback model\r\n                const fallbackModel = genAI!.getGenerativeModel({ model: GEMINI_CONFIG.FALLBACK_MODEL_NAME });\r\n                const prompt = SYSTEM_PROMPTS.POKEMON_MASTER(lastWord, aiWord);\r\n                const result = await fallbackModel.generateContent(prompt);\r\n                const response = result.response;\r\n                const text = response.text();\r\n\r\n                return text.trim();\r\n            } catch (fallbackError: any) {\r\n                console.error('Gemini API Error (Fallback Model):', fallbackError);\r\n                return `${aiWord}! (AIê°€ ì§€ê¸ˆ ë„ˆë¬´ í”¼ê³¤í•´ì„œ... ì ê¹ ì‰´ê²Œ ğŸ˜´)`;\r\n            }\r\n        }\r\n\r\n        // Fallback to basic message\r\n        return `${aiWord}! (AI ì—°ê²° ìƒíƒœê°€ ì¢‹ì§€ ì•Šì•„...)`;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\User\\Workspace\\poke-word-chain\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]